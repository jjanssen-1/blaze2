// If/else control flow: all variations of branching.

// Simple if with else.
fn max(a: i32, b: i32) -> i32 {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

// If without else â€” void function.
fn maybe_do(flag: bool) {
  if (flag) {
    42;
  }
}

// If without else, with code after.
fn clamp_positive(x: i32) -> i32 {
  var result: i32 = x;
  if (x < 0) {
    result = 0;
  }
  return result;
}

// If-else-if chain (else containing an if statement).
fn sign(x: i32) -> i32 {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return 0 - 1;
  } else {
    return 0;
  }
}

// Deeply nested if/else â€” three levels.
fn classify(a: i32, b: i32, c: i32) -> i32 {
  if (a > 0) {
    if (b > 0) {
      if (c > 0) {
        return 1;
      } else {
        return 2;
      }
    } else {
      return 3;
    }
  } else {
    return 4;
  }
}

// Both branches assign to same variable, used after merge.
fn assign_both_branches(flag: bool) -> i32 {
  var x: i32 = 0;
  if (flag) {
    x = 10;
  } else {
    x = 20;
  }
  return x;
}

// Only then-branch assigns; variable initialized before if.
fn assign_then_only(flag: bool) -> i32 {
  var x: i32 = 5;
  if (flag) {
    x = 99;
  }
  return x;
}

// Multiple statements in each branch.
fn multi_stmt_branches(a: i32, b: i32) -> i32 {
  var result: i32 = 0;
  if (a > b) {
    var diff_ab: i32 = a - b;
    result = diff_ab * 2;
  } else {
    var diff_ba: i32 = b - a;
    result = diff_ba * 3;
  }
  return result;
}

// Early return in then-branch, fallthrough in else path.
fn early_return_then(x: i32) -> i32 {
  if (x > 100) {
    return 100;
  }
  return x;
}

// Early return in both branches.
fn early_return_both(x: i32) -> i32 {
  if (x > 0) {
    return x;
  } else {
    return 0 - x;
  }
}

// If with a complex condition expression.
fn complex_condition(a: i32, b: i32) -> i32 {
  if (a + b > a * b) {
    return a;
  } else {
    return b;
  }
}

// If condition is a boolean variable.
fn bool_var_condition(flag: bool) -> i32 {
  if (flag) {
    return 1;
  } else {
    return 0;
  }
}

// If condition is negated boolean.
fn negated_condition(flag: bool) -> i32 {
  if (!flag) {
    return 1;
  } else {
    return 0;
  }
}

// If condition is a function call result.
fn is_big(x: i32) -> bool {
  return x > 100;
}

fn check_big(x: i32) -> i32 {
  if (is_big(x)) {
    return 100;
  }
  return x;
}

// Nested if inside else branch.
fn nested_in_else(a: i32, b: i32) -> i32 {
  if (a > 10) {
    return a;
  } else {
    if (b > 10) {
      return b;
    } else {
      return 0;
    }
  }
}

// Sequential (non-nested) if statements.
fn sequential_ifs(x: i32) -> i32 {
  var result: i32 = x;
  if (x > 10) {
    result = result - 10;
  }
  if (result > 5) {
    result = result - 5;
  }
  return result;
}

// If-else with boolean literal as condition.
fn literal_true_cond() -> i32 {
  if (true) {
    return 1;
  } else {
    return 0;
  }
}

fn literal_false_cond() -> i32 {
  if (false) {
    return 1;
  } else {
    return 0;
  }
}

// Void function with if-else that has expression statements only.
fn side_effects_only(a: i32, b: i32) {
  if (a > b) {
    a + b;
  } else {
    a - b;
  }
}

// Three-level if-else-if-else chain.
fn three_way(x: i32) -> i32 {
  if (x > 100) {
    return 3;
  } else if (x > 50) {
    return 2;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
}
