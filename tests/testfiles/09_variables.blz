// Variables: var/const declarations, scoping, reassignment, SSA behavior.

// Simple variable declaration with initializer.
fn simple_var() -> i32 {
  var x: i32 = 42;
  return x;
}

// Const declaration.
fn simple_const() -> i32 {
  const x: i32 = 99;
  return x;
}

// Multiple variable declarations.
fn multi_var() -> i32 {
  var a: i32 = 1;
  var b: i32 = 2;
  var c: i32 = 3;
  return a + b + c;
}

// Variable initialized from another variable.
fn var_from_var() -> i32 {
  var x: i32 = 10;
  var y: i32 = x;
  return y;
}

// Variable initialized from an expression involving other variables.
fn var_from_expr() -> i32 {
  var a: i32 = 3;
  var b: i32 = 4;
  var c: i32 = a * b + 1;
  return c;
}

// Variable reassignment (SSA: each assignment produces a new register).
fn reassignment() -> i32 {
  var x: i32 = 1;
  x = 2;
  x = 3;
  return x;
}

// Variable reassigned from itself (accumulation).
fn self_reassign() -> i32 {
  var x: i32 = 1;
  x = x + 1;
  x = x + 1;
  x = x + 1;
  return x;
}

// Variable assigned from a function call result.
fn helper(x: i32) -> i32 {
  return x * 2;
}

fn var_from_call() -> i32 {
  var result: i32 = helper(5);
  return result;
}

// Variable reassigned from a function call result.
fn var_reassign_from_call() -> i32 {
  var x: i32 = 0;
  x = helper(3);
  x = helper(x);
  return x;
}

// Boolean variable.
fn bool_var() -> bool {
  var flag: bool = true;
  return flag;
}

// Boolean variable reassigned.
fn bool_reassign() -> bool {
  var flag: bool = true;
  flag = false;
  return flag;
}

// Boolean variable from comparison.
fn bool_from_compare(a: i32, b: i32) -> bool {
  var result: bool = a < b;
  return result;
}

// Variable used in a condition.
fn var_in_condition(x: i32) -> i32 {
  var positive: bool = x > 0;
  if (positive) {
    return x;
  }
  return 0;
}

// Variable declared inside an if branch (scoped to that block).
fn scoped_in_if(flag: bool) -> i32 {
  var result: i32 = 0;
  if (flag) {
    var temp_a: i32 = 42;
    result = temp_a;
  } else {
    var temp_b: i32 = 99;
    result = temp_b;
  }
  return result;
}

// Variable declared inside a while loop body.
fn var_in_loop(n: i32) -> i32 {
  var total: i32 = 0;
  var i: i32 = 0;
  while (i < n) {
    var contribution: i32 = i * 2;
    total = total + contribution;
    i = i + 1;
  }
  return total;
}

// Many variables — stress the register allocator.
fn many_vars() -> i32 {
  var a: i32 = 1;
  var b: i32 = 2;
  var c: i32 = 3;
  var d: i32 = 4;
  var e: i32 = 5;
  var f: i32 = 6;
  var g: i32 = 7;
  var h: i32 = 8;
  var i: i32 = 9;
  var j: i32 = 10;
  return a + b + c + d + e + f + g + h + i + j;
}

// Variable initialized to zero, then conditionally updated.
fn conditional_update(flag: bool) -> i32 {
  var x: i32 = 0;
  if (flag) {
    x = 100;
  }
  return x;
}

// Variable used as argument to multiple calls.
fn var_multi_use(n: i32) -> i32 {
  var x: i32 = n + 1;
  var a: i32 = helper(x);
  var b: i32 = helper(x);
  return a + b;
}

// Const variable — ensure it can be read.
fn const_read() -> i32 {
  const pi_approx: i32 = 3;
  var result: i32 = pi_approx * pi_approx;
  return result;
}

// Variable in a nested block (no shadowing — resolver disallows it).
fn var_in_block() -> i32 {
  var x: i32 = 1;
  {
    var y: i32 = 2;
    x = x + y;
  }
  return x;
}

// Variable declared and used immediately in same expression.
fn immediate_use() -> i32 {
  var x: i32 = 5;
  var y: i32 = x + x;
  return y;
}

// Variable assigned from boolean negation.
fn negate_var(b: bool) -> bool {
  var result: bool = !b;
  return result;
}

// Multiple reassignments with different expressions.
fn varied_reassign(a: i32, b: i32) -> i32 {
  var x: i32 = a;
  x = b;
  x = a + b;
  x = a * b;
  x = x - 1;
  return x;
}

// Variable used across an if-else, both branches read it.
fn read_across_branches(x: i32) -> i32 {
  var base: i32 = x * 2;
  if (x > 0) {
    return base + 1;
  } else {
    return base - 1;
  }
}

// Variable assigned in a loop, read after the loop.
fn loop_accumulator() -> i32 {
  var sum: i32 = 0;
  var i: i32 = 1;
  while (i <= 5) {
    sum = sum + i;
    i = i + 1;
  }
  return sum;
}

// Two variables swapped via a temp (classic swap pattern).
fn swap_pattern(a: i32, b: i32) -> i32 {
  var x: i32 = a;
  var y: i32 = b;
  var temp: i32 = x;
  x = y;
  y = temp;
  // Return x, which should now hold b's original value.
  return x;
}

// Variable initialized from a deeply nested expression.
fn deep_init(a: i32, b: i32, c: i32) -> i32 {
  var result: i32 = ((a + b) * (c - a)) + ((b * c) - (a + c));
  return result;
}
